webpackHotUpdate("app",{

/***/ "./src/helpers/alignGrid.ts":
/*!**********************************!*\
  !*** ./src/helpers/alignGrid.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar clump_1 = __webpack_require__(/*! ./clump */ \"./src/helpers/clump.ts\");\nvar TILE_SIZE = 50;\nvar clumpables = new Set(['dirt', 'lava', 'crate', 'steel']);\nvar AlignGrid = /** @class */ (function () {\n    function AlignGrid(config) {\n        this.counter = 0;\n        this.clumps = new Map();\n        if (!config.scene) {\n            console.log('missing scene!');\n            return;\n        }\n        if (!config.rows) {\n            console.log('no rows given wee woo');\n        }\n        if (!config.cols) {\n            console.log('no columns given wee woo');\n        }\n        this.h = config.rows * TILE_SIZE;\n        this.w = config.cols * TILE_SIZE;\n        this.rows = config.rows;\n        this.cols = config.cols;\n        this.scene = config.scene;\n        this.grid = new Array(this.rows);\n        this.selected = 'lavaTile';\n        for (var i = 0; i < this.cols; i++) {\n            this.grid[i] = new Array(this.rows);\n        }\n        this.playerTile = null;\n    }\n    AlignGrid.prototype.show = function (a) {\n        if (a === void 0) { a = 0.7; }\n        this.graphics = this.scene.add.graphics();\n        this.graphics.lineStyle(1, 0xff0000, a);\n        for (var i = 0; i < this.w; i += TILE_SIZE) {\n            this.graphics.moveTo(i, 0);\n            this.graphics.lineTo(i, this.h);\n        }\n        for (var i = 0; i < this.h; i += TILE_SIZE) {\n            this.graphics.moveTo(0, i);\n            this.graphics.lineTo(this.w, i);\n        }\n        this.graphics.strokePath();\n    };\n    AlignGrid.prototype.placeAt = function (x1, y1, objName, game) {\n        var _this = this;\n        //converted centered coordinates in pixels to place in grid square\n        var row = Math.floor(x1 / TILE_SIZE);\n        var col = Math.floor(y1 / TILE_SIZE);\n        var x2 = row * TILE_SIZE + TILE_SIZE / 2;\n        var y2 = col * TILE_SIZE + TILE_SIZE / 2;\n        //if clearing instead\n        if (objName == 'clear') {\n            if (this.grid[row][col]) {\n                var name_1 = this.grid[row][col].name;\n                var frame = this.grid[row][col].frame.name;\n                console.log(this.grid[row][col].frame);\n                if (name_1 == 'player') {\n                    return;\n                }\n                this.grid[row][col].destroy();\n                this.grid[row][col] = null;\n                if (clumpables.has(name_1) && frame != 0) {\n                    this.neighbors(row, col).forEach(function (e) {\n                        var nx = _this.unpack(e)[0];\n                        var ny = _this.unpack(e)[1];\n                        if (_this.grid[nx][ny] && _this.grid[nx][ny].frame.name != 0) {\n                            _this.clump(nx, ny, nx, ny);\n                        }\n                    });\n                }\n            }\n            this.grid[row][col] = null;\n            return;\n        }\n        var obj = game.add.image(x2, y2, objName);\n        obj.name = objName;\n        if (this.grid[row][col]) {\n            if (this.playerTile && this.playerTile[0] == row && this.playerTile[1] == col) {\n                this.playerTile = null;\n            }\n            this.grid[row][col].destroy();\n        }\n        if (objName == 'player') {\n            if (this.playerTile) {\n                this.grid[this.playerTile[0]][this.playerTile[1]].destroy();\n            }\n            this.playerTile = [row, col];\n        }\n        this.grid[row][col] = obj;\n        obj.x = x2;\n        obj.y = y2;\n    };\n    AlignGrid.prototype.getRowOrCol = function (pixel) {\n        return Math.floor(pixel / TILE_SIZE);\n    };\n    AlignGrid.prototype.getPixel = function (rowOrCol) {\n        return rowOrCol * TILE_SIZE + TILE_SIZE / 2;\n    };\n    AlignGrid.prototype.neighbors = function (i, j) {\n        return [\n            i - 1 + ',' + (j - 1),\n            i + ',' + (j - 1),\n            i + 1 + ',' + (j - 1),\n            i + 1 + ',' + j,\n            i + 1 + ',' + (j + 1),\n            i + ',' + (j + 1),\n            i - 1 + ',' + (j + 1),\n            i - 1 + ',' + j,\n        ];\n    };\n    AlignGrid.prototype.unpack = function (coord) {\n        var split = coord.indexOf(',');\n        var i = parseInt(coord.substring(0, split));\n        var j = parseInt(coord.substring(split + 1));\n        return [i, j];\n    };\n    /**\n     * start and end of rectangle drawn by mouse to clump selected tiles\n     * FIX TO TAKE SET OF TILES INSTEAD OF RECTANGLE? TODO\n     * @param sx start x pixel coordinate\n     * @param sy start y pixel coordinate\n     * @param ex end x pixel coordinate\n     * @param ey end y pixel coordinate\n     */\n    AlignGrid.prototype.clump = function (sr, sc, er, ec) {\n        var _this = this;\n        var curr = new Set();\n        var check = new Set();\n        // const sr = this.getRowOrCol(sx);\n        // const sc = this.getRowOrCol(sy);\n        // const er = this.getRowOrCol(ex);\n        // const ec = this.getRowOrCol(ey);\n        // const sr = 0;\n        // const sc = 0;\n        // const er = 10;\n        // const ec = 10;\n        // DO BFS\n        for (var i = sr; i <= er; i++) {\n            for (var j = sc; j <= ec; j++) {\n                if (this.grid[i][j]) {\n                    curr.add(i + ',' + j);\n                    check.add(i + ',' + j);\n                    if (this.grid[i][j].frame.name != 0) {\n                        this.neighbors(i, j).forEach(function (e) {\n                            var nx = _this.unpack(e)[0];\n                            var ny = _this.unpack(e)[1];\n                            if (_this.grid[nx][ny] && _this.grid[nx][ny].frame.name != 0) {\n                                check.add(e);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        // figure out which tile texture to use based on spritesheet\n        // ensured that none are null in curr\n        curr.forEach(function (e) {\n            var i = _this.unpack(e)[0];\n            var j = _this.unpack(e)[1];\n            if (clumpables.has(_this.grid[i][j].name)) {\n                var candidates = _this.neighbors(i, j);\n                // all sides of the tile grabbed from the tilesheets\n                var id = [1, 1, 1, 1, 1, 1, 1, 1];\n                var pointer = 0;\n                for (var x = 0; x < candidates.length; x++) {\n                    var coord = candidates[x];\n                    var a = _this.unpack(coord)[0];\n                    var b = _this.unpack(coord)[1];\n                    if (!(check.has(coord) && _this.grid[a][b].name == _this.grid[i][j].name)) {\n                        if (x % 2 == 0) {\n                            id[pointer] = 0;\n                        }\n                        else {\n                            id[pointer] = 0;\n                            id[pointer + 1] = 0;\n                            // wrap around to 7\n                            if (pointer + 2 > 7) {\n                                id[0] = 0;\n                            }\n                            else {\n                                id[pointer + 2] = 0;\n                            }\n                        }\n                    }\n                    // console.log(pointer);\n                    if (x % 2 == 1) {\n                        pointer += 2;\n                    }\n                }\n                _this.grid[i][j].setFrame(clump_1.tiles[id.join('')]);\n            }\n        });\n    };\n    return AlignGrid;\n}());\nexports.default = AlignGrid;\n\n\n//# sourceURL=webpack:///./src/helpers/alignGrid.ts?");

/***/ }),

/***/ "./src/helpers/clump.ts":
/*!******************************!*\
  !*** ./src/helpers/clump.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.indexes = exports.tiles = void 0;\nexports.tiles = {\n    '00000000': 0,\n    '00010000': 1,\n    '00010001': 2,\n    '00000001': 3,\n    '00010100': 4,\n    '00000101': 5,\n    '01010100': 6,\n    '00010101': 7,\n    '01110101': 8,\n    '01011101': 9,\n    '11010111': 10,\n    '11110101': 11,\n    '00000100': 12,\n    '00011100': 13,\n    '00011111': 14,\n    '00000111': 15,\n    '01010000': 16,\n    '01000001': 17,\n    '01010001': 18,\n    '01000101': 19,\n    '11010101': 20,\n    '01010111': 21,\n    '01011111': 22,\n    '01111101': 23,\n    '01000100': 24,\n    '01111100': 25,\n    '11111111': 26,\n    '11000111': 27,\n    '01011100': 28,\n    '00010111': 29,\n    '01110100': 30,\n    '00011101': 31,\n    '11110111': 32,\n    '11111101': 33,\n    '01110111': 34,\n    '11011101': 35,\n    '01000000': 36,\n    '01110000': 37,\n    '11110001': 38,\n    '11000001': 39,\n    '01110001': 40,\n    '11000101': 41,\n    '11010001': 42,\n    '01000111': 43,\n    '11011111': 44,\n    '01111111': 45,\n    '01010101': 46,\n};\nvar indexesTemp = {};\nfor (var _i = 0, _a = Object.entries(exports.tiles); _i < _a.length; _i++) {\n    var _b = _a[_i], key = _b[0], value = _b[1];\n    exports.indexes[value][key];\n}\nexports.indexes = indexesTemp;\n\n\n//# sourceURL=webpack:///./src/helpers/clump.ts?");

/***/ })

})