{"version":3,"file":"phaser-raycaster.js","mappings":"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,OAAL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKX,MAAL,GAAc,KAAd;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKhB,MAAL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKkC,OAAL,GAAe,EAAf;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKmC,SAAL,GAAiB,EAAjB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKxD,SAAL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKC,WAAL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKf,cAAL;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKgB,SAAL;EAEA,KAAKJ,MAAL,CAAYnB,OAAZ;EACA,IAAG,CAAC,KAAKkC,YAAT,EACI,KAAKX,SAAL;EAEJ,OAAO,IAAP;AACH;AAAA;AAEDgG,GAAG,CAAC5I,SAAJ,GAAgB;EACZwC,MAAM,EAAEhB,sEADI;EAEZZ,OAAO,EAAEY,yEAA+BZ;AAF5B,CAAhB;AAKAgI,GAAG,CAAC5I,SAAJ,CAAcuB,WAAd,GAA4BqH,GAA5B;;;;;;;;;;;;;;;;;ACnJA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASlG,SAAT,GAAgC;EAAA,IAAboB,GAAa,uEAAP,KAAO;EACnC,IAAG,CAAC,KAAKL,MAAT,EACI,OAAO,EAAP;EACJ,OAAO,KAAKM,OAAZ;AACH;AAAA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,SAASpB,WAAT,GAAuB;EAC1B,IAAG,CAAC,KAAKc,MAAT,EACI,OAAO,EAAP;EACJ,OAAO,KAAKyC,SAAZ;AACH;AAAA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AAC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AhC,EAAf;EACP;EAED,IAAGuC,MAAM,CAACC,IAAP,CAAYqD,UAAZ,CAAuB2N,iBAAvB,CAAyC,KAAKnK,oBAA9C,EAAoEoL,YAApE,CAAH,EACI,OAAO,IAAP;EAEJ,OAAO,KAAP;AACH;;;;;;;;;;;;;;;AC7HD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,GAAT,CAAajV,OAAb,EAAsBwH,SAAtB,EAAiC;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,KAAKlC,UAAL,GAAkBkC,SAAS,GAAGA,SAAH,GAAe,KAA1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKtD,MAAL,GAAc,IAAIpB,MAAM,CAACC,IAAP,CAAYC,KAAhB,EAAd;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKoI,IAAL,GAAY,IAAItI,MAAM,CAACC,IAAP,CAAYS,IAAhB,EAAZ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKiB,KAAL,GAAa,CAAb;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKiK,IAAL,GAAY,CAAZ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKrD,QAAL,GAAgBvI,MAAM,CAACsB,IAAP,CAAYoF,gBAA5B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKD,cAAL,GAAsB,CAAtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKK,oBAAL,GAA4B,IAAI9G,MAAM,CAACC,IAAP,CAAYsE,MAAhB,EAA5B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKiI,cAAL,GAAsBxM,MAAM,CAACsB,IAAP,CAAYoF,gBAAlC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAK4D,wBAAL,GAAgC,IAAhC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;EACI,KAAKC,KA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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/before-startup","webpack://PhaserRaycaster/webpack/startup","webpack://PhaserRaycaster/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","var PhaserRaycaster = function (scene)\n{\n    //The Scene that owns this plugin\n    this.scene = scene;\n\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted)\n    {\n        scene.sys.events.once('boot', this.boot, this);\n    }\n};\n\n//Static function called by the PluginFile Loader.\nPhaserRaycaster.register = function (PluginManager)\n{\n    //  Register this plugin with the PluginManager, so it can be added to Scenes.\n\n    //  The first argument is the name this plugin will be known as in the PluginManager. It should not conflict with already registered plugins.\n    //  The second argument is a reference to the plugin object, which will be instantiated by the PluginManager when the Scene boots.\n    //  The third argument is the local mapping. This will make the plugin available under `this.sys.base` and also `this.base` from a Scene if\n    //  it has an entry in the InjectionMap.\n    PluginManager.register('PhaserRaycaster', PhaserRaycaster, 'base');\n};\n\nPhaserRaycaster.prototype = {\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot: function ()\n    {\n        var eventEmitter = this.systems.events;\n\n        //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n        //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n        eventEmitter.on('start', this.start, this);\n\n        eventEmitter.on('preupdate', this.preUpdate, this);\n        eventEmitter.on('update', this.update, this);\n        eventEmitter.on('postupdate', this.postUpdate, this);\n\n        eventEmitter.on('pause', this.pause, this);\n        eventEmitter.on('resume', this.resume, this);\n\n        eventEmitter.on('sleep', this.sleep, this);\n        eventEmitter.on('wake', this.wake, this);\n\n        eventEmitter.on('shutdown', this.shutdown, this);\n        eventEmitter.on('destroy', this.destroy, this);\n    },\n\n    //A test method.\n    test: function (name)\n    {\n        console.log('RaycasterPlugin says hello ' + name + '!');\n    },\n\n    //Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start: function ()\n    {\n    },\n\n    //Called every Scene step - phase 1\n    preUpdate: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 2\n    update: function (time, delta)\n    {\n    },\n\n    //Called every Scene step - phase 3\n    postUpdate: function (time, delta)\n    {\n    },\n\n    //Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause: function ()\n    {\n    },\n\n    //Called when a Scene is resumed from a paused state.\n    resume: function ()\n    {\n    },\n\n    //Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep: function ()\n    {\n    },\n\n    //Called when a Scene is woken from a sleeping state.\n    wake: function ()\n    {\n    },\n\n    //Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown: function ()\n    {\n    },\n\n    //Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.scene = undefined;\n    },\n\n    //Create Raycaster object\n    createRaycaster: function(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n\n};\n\nPhaserRaycaster.prototype.constructor = PhaserRaycaster;\nPhaserRaycaster.prototype._Raycaster = require('./raycaster-core.js').Raycaster;\n\n//Make sure you export the plugin for webpack to expose\n\nmodule.exports = PhaserRaycaster;\n","/**\n* Get mapped object's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\n*/\nexport function getBoundingBox() {\n    return this.object.getBounds();\n}\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\nlet matterBody = require('./map-matterBody-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet boundingBox = require('./boundingBox.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * @param {integer} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    if(options.type === 'body' || options.type === 'composite')\n        options.type = 'MatterBody';\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.circle = (options.segmentCount) ? false : true;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            //container's child\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            //transformed container's circle children\n            this._circles = [];\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = container.updateMap;\n            this._updateChildMap = container._updateChildMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'TilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'MatterBody':\n            //force convex body (hull) mapping\n            this.forceConvex = (options.forceConvex) ? true : false;\n            //force mapping by vertices\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\n            this.circle = false;\n            this.getPoints = matterBody.getPoints;\n            this.getSegments = matterBody.getSegments;\n            this.getBoundingBox = matterBody.getBoundingBox;\n            this.updateMap = matterBody.updateMap;\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //if object is not supported\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\n        this.notSupported = true;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n* @param {bool} [isChild] - Flag definig if it is child container.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, isChild = false) {\n    if(!this.active)\n        return [];\n\n    let points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(this.segmentCount == 0 && !isChild) {\n        if(ray) {\n            //create temporary ray\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n    \n            let tempRay = ray._raycaster.createRay({\n                origin: {\n                    x: vector.getPointB().x,\n                    y: vector.getPointB().y\n                }\n            });\n\n            //calculate tangent rays\n            let rayA = new Phaser.Geom.Line();\n            let rayB = new Phaser.Geom.Line();\n            let c;\n\n            for(let circle of this._circles) {\n                circle.points = [];\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\n\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\n\n                //ray angle\n                let angle = Phaser.Geom.Line.Angle(c);\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n                //adding tangent points\n                circle.points.push(rayA.getPointB());\n                circle.points.push(rayB.getPointB());\n                points.push(rayA.getPointB());\n                points.push(rayB.getPointB());\n            }\n        }\n    }\n    \n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n    this._circles = [];\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    if(this.mapChild) {\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\n    }\n    else {\n        //iterate through container's children\n        container.iterate(function(child){\n            this._updateChildMap(child, points, segments, rotation, offset);\n        }.bind(this));\n\n        //get children intersections\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\n            let childA = container.list[i];\n            let mapA = childA.data.get('raycasterMap');\n            \n            if(!mapA)\n                continue;\n\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n                let childB = container.list[j];\n                let mapB = childB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                    continue;\n\n                //find objects intersections\n                for(let segmentA of mapA.getSegments()) {\n                    for(let segmentB of mapB.getSegments()) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        //calculate positions after container's rotation\n                        if(rotation !== 0) {\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                            points.push(vector.getPointB());\n                        }\n                        //if rotation === 0\n                        else\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                    }\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n\n/**\n* Update container's child map of points and segments.\n*\n* @method Raycaster.Map#container._updateChildMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.10.3\n*\n* @param {object} [child] - Container's child object.\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\n* @param {float} [rotation] - Container's rotation.\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\n*/\nexport function _updateChildMap(child, points, segments, rotation, offset) {\n    if(!child.data)\n        child.setDataEnabled();\n\n    //if object is not supported\n    if(child.data.get('raycasterMapNotSupported'))\n        return;\n\n    //get child map\n    let map = child.data.get('raycasterMap');\n    if(!map) {\n        map = new this.constructor({\n            object: child,\n            segmentCount: this.segmentCount\n        });\n\n        if(map.notSupported) {\n            map.destroy();\n            child.data.set('raycasterMapNotSupported', true);\n            return;\n        }\n\n        child.data.set('raycasterMap', map);\n    }\n    else\n        map.updateMap();\n\n    //add child points\n    let childPoints = [];\n    for(let point of map.getPoints(false, true)) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n        //if rotation === 0\n        else\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n\n        childPoints.push(points[points.length - 1])\n    }\n\n    //add child segments\n    for(let segment of map.getSegments()) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let pointA = segment.getPointA();\n            let pointB = segment.getPointB();\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n        }\n        //if rotation === 0\n        else\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\n    }\n\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\n    if(map.type == 'Arc' && this.segmentCount == 0) {\n        let circleOffset = new Phaser.Geom.Point();\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\n\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            circleOffset = vector.getPointB();\n        }\n\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\n    }\n    else if(map.type === 'Container') {\n        for(let childMapCircle of map._circles) {\n            let circleOffset = new Phaser.Geom.Point();\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\n\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                circleOffset = vector.getPointB();\n            }\n\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\n        }\n    }\n}\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Map#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.9.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map#dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this.dynamic;\n    /**\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\n    *\n    * @name Raycaster.Map#circle\n    * @type {boolean}\n    * @default false\n    * @since 0.9.0\n    */\n    this.circle = false;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycatser.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Get mapped object's bounding box.\n    *\n    * @method Raycaster.Map#getBoundingBox\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.9.0\n    *\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\n    */\n    this.getBoundingBox;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n\n    this.config(options);\n    if(!this.notSupported)\n        this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config,\n    destroy: require('./destroy.js').destroy\n};\n\nMap.prototype.constructor = Map;\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for matter body*/\n/**\n* Get array of mapped matter body's vertices used as rays targets.\n*\n* @method Raycaster.Map#matterBody.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n\n    //calculate tangent rays\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\n        let points = [];\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n\n        return points;\n    }\n\n    return this._points;\n};\n\n/**\n* Get array of mapped matter body's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#matterBody.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update matter body's map of points and segments.\n*\n* @method Raycaster.Map#matterBody.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n    let bodies = [body];\n    let generateBounds = false;\n\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\n        this.circle = true;\n        this._points = points;\n        this._segments = segments;\n\n        return this;\n    }\n\n    this.circle = false;\n\n    if(body.type == 'composite')\n        bodies = body.bodies;\n\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\n        generateBounds = true;\n    }\n    \n    for(let bodyItem of bodies) {\n        //if convex body\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\n            let vertices = bodyItem.parts[0].vertices;\n\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\n\n            for(let i = 1, length = vertices.length; i < length; i++) {\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\n\n                points.push(pointB);\n\n                //add segment\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                segments.push(segment);\n            }\n\n            //closing segment\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n            segments.push(segment);\n        }\n\n        //if concave body\n        else if(bodyItem.parts.length > 1) {\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\n                let vertices = bodyItem.parts[i].vertices;\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\n\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\n                    points.push(pointA);\n\n                for(let j = 1, length = vertices.length; j < length; j++) {\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\n                    //check if segment was already added\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\n                    \n                    if(segmentIndex !== -1) {\n                        segments.splice(segmentIndex, 1);\n                        pointA = pointB;\n                        continue;\n                    }\n                    \n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\n                        points.push(pointB);\n\n                    //add segment\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                    segments.push(segment);\n                    \n                    pointA = pointB;\n                }\n                \n                //closing segment\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\n                if(segmentIndex === undefined)\n                    segments.push(closingSegment);\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    if(generateBounds) {\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\n        body.bounds = bounds;\n    }\n\n    return this;\n};\n\n/**\n* Get matter body's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\n*/\nexport function getBoundingBox() {\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\n\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n}\n\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycatser.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {integer} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n    this.circle = count ? false : true;\n\n    this.updateMap();\n    return this;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {float} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {float} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestSegment;\n    let closestObject;\n    let closestDistance = this.rayRange;\n    let internal = options.internal ? options.internal : false;\n    let startTime = performance.now();\n    let stats = {\n        method: 'cast',\n        rays: 1,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map, boundingBox;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        stats.testedMappedObjects++;\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        if(internal) {\n            boundingBox = map._boundingBox;\n        }\n        else {\n            boundingBox = map.getBoundingBox();\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n        }\n\n        //check if object is intersected by ray\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox).length === 0)\n            continue;\n\n        stats.hitMappedObjects++;\n        stats.segments += map.getSegments(this).length;\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n                closestObject = map.object;\n                closestSegment = segment;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            closestObject = map.object;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                        closestObject = map.object;\n                    }\n                }\n            }\n        }\n\n        //check container map's circles\n        if(map.type == 'Container' && map._circles.length > 0) {\n            for(let circle of map._circles) {\n                //check if target point is a circle tangent point to ray\n                if(options.target) {\n                    let isTangent = false;\n\n                    for(let point of circle.points) {\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\n                            //get closest intersection\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                            if(distance < closestDistance) {\n                                closestDistance = distance;\n                                closestIntersection = point;\n                                closestObject = map.object;\n                                isTangent = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(isTangent)\n                        continue;\n                }\n\n                let circleIntersections = [];\n\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                    for(let intersection of circleIntersections) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = intersection;\n                            closestObject = map.object;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //update stats\n    if(internal) {\n        this._stats.rays++;\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\n        this._stats.segments += stats.segments;\n    }\n    else {\n        stats.time = performance.now() - startTime;\n        this._stats = stats;\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n        result.segment = closestSegment;\n        result.object = closestObject;\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n\n    if(!internal)\n        this.drawDebug([result]);\n    \n    return result;\n}","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCircle',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else {\n                mapB = objectB.data.get('raycasterMap');\n            }\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                    rayTargets.push({\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                    });\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angle - b.angle;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            \n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCone',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: angle,\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n    \n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {float} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {float} [options.angle = 0] - Ray's angle in radians.\n * @param {float} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {float} [options.cone = 0] - Ray's cone angle in radians.\n * @param {float} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {integer} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {integer} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {integer} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        this.graphics.setDepth(1000);\n    }\n\n    return this;\n}\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n        this.setOnCollideActive();\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n","/*Matter physics methods for ray body*/\n/**\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\n * categories are included in their collision masks (see {@link #setCollidesWith}).\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique category bitfield.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionCategory(value) {\n    this.body.collisionFilter.category = value;\n\n    return this;\n};\n\n/**\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\n * they will never collide.\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique group index.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionGroup(value) {\n    this.body.collisionFilter.group = value;\n\n    return this;\n};\n\n/**\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\n * and `(categoryB & maskA) !== 0` are both true.*\n *\n * @method Raycaster.Ray#setCollidesWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\n\nexport function setCollidesWith(categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories))\n    {\n        flags = categories;\n    }\n    else\n    {\n        for (var i = 0; i < categories.length; i++)\n        {\n            flags |= categories[i];\n        }\n    }\n\n    this.body.collisionFilter.mask = flags;\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollide\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollide(callback) {\n    let self = this;\n    this.body.onCollideCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(collisionInfo);\n        }\n    };\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideEnd\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideEnd(callback) {\n    this.body.onCollideEndCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            collisionInfo.rayCollided = false;\n            callback(collisionInfo);\n        }\n    }\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideActive\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideActive(callback) {\n    let self = this;\n    let func = function(collisionInfo) {\n        if(self.processOverlap(collisionInfo)) {\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\n\n            if(collisionInfo.rayCollided !== true) {\n                collisionInfo.rayCollided = true;\n                if(self.body.onCollideCallback) {\n                    self.body.onCollideCallback(collisionInfo);\n                }\n\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\n                    self.body.onCollideWith[body.id](body, collisionInfo);\n                }\n            }\n            if(callback)\n                callback(collisionInfo);\n        }\n        else {\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\n                self.body.onCollideEndCallback(collisionInfo);\n            }\n        }\n    }\n\n    this.body.onCollideActiveCallback = func;\n\n    return this;\n}\n\n/**\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideWith(body, callback) {\n    let self = this;\n    let func = function(body, collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(body, collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(body, collisionInfo);\n        }\n    }\n\n    if (!Array.isArray(body))\n    {\n        body = [ body ];\n    }\n\n    for (var i = 0; i < body.length; i++)\n    {\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\n\n        this.body.setOnCollideWith(src, func);\n    }\n\n    return this;\n};\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let obj1, obj2, target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        obj1 = object1.bodyA;\n        obj2 = object1.bodyB;\n    }\n    else {\n        obj1 = object1;\n        obj2 = object2;\n    }\n\n    if(obj1._ray !== undefined && obj1._ray === this)\n        target = obj2;\n    else if(obj2._ray !== undefined && obj2._ray === this)\n        target = obj1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {integer} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 6.0.0\n *\n * @param {object} options - Ray specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {float}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {float}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {integer}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {integer}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(bolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    /**\n    * Ray casting stats.\n    *\n    * @name Raycaster.Ray#_stats\n    * @type {object}\n    * @private\n    * @since 0.10.0\n    * \n    * @property {string} method Used casting method (cast, castCircle, castCone).\n    * @property {number} rays Casted rays.\n    * @property {number} testedMappedObjects Tested mapped objects.\n    * @property {number} hitMappedObjects Hit mapped objects.\n    * @property {number} segments Tested segments.\n    * @property {number} time Casting time.\n    */\n    this._stats = {\n        method: 'cast',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    /**\n    * Ray's graphics object used for debug\n    *\n    * @name Raycaster.Ray#graphics\n    * @type {Phaser.GameObjects.Graphics}\n    * @private\n    * @since 0.10.0\n    */\n     this.graphics;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    getStats: require('./stats.js').getStats,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\n    drawDebug: require('./debug.js').drawDebug,\n    destroy: require('./destroy.js').destroy,\n};\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {integer} x - X coordinate.\n * @param {integer} y - Y coordinate.\n * @param {float} [angle] - Ray's angle in radians.\n * @param {integer} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2021 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {bool|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.4';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {bool} [enable = false] Enable debug mode\r\n    * @property {bool} [maps = true] - Enable maps debug\r\n    * @param {bool} [rays = true] - Enable rays debug\r\n    * @property {bool} graphics - Debug graphics options\r\n    * @property {bool|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {bool|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {bool|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {integer}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {integer} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {bool|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n            \r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycatser's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {integer} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {integer} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {integer} width - The width of bounding box.\r\n    * @param {integer} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic++;\r\n            else\r\n                this._stats.mappedObjects.static++;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                object.raycasterMap.destroy();\r\n            else\r\n                object.data.get('raycasterMap').destroy();\r\n            \r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic--;\r\n            else\r\n                this._stats.mappedObjects.static--;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        let dynamicMaps = 0;\r\n        if(this.mappedObjects.length > 0) {\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.dynamic) {\r\n                    map.updateMap();\r\n                    dynamicMaps++;\r\n                }\r\n            }\r\n\r\n            //update stats\r\n            this._stats.mappedObjects.static = this.mappedObjects.length - dynamicMaps;\r\n            this._stats.mappedObjects.dynamic = dynamicMaps;\r\n\r\n            //debug\r\n            if(this.debugOptions.enabled)\r\n                this.drawDebug();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray options:\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n\r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main.js\");\n",""],"names":["PhaserRaycaster","scene","systems","sys","settings","isBooted","events","once","boot","register","PluginManager","prototype","eventEmitter","on","start","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","destroy","test","name","console","log","time","delta","undefined","createRaycaster","options","_Raycaster","constructor","require","Raycaster","module","exports","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","raycasterMap","data","remove","key","ray","_points","length","points","offset","Phaser","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","rayA","Line","rayB","c","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","_segments","scaleY","geom","segments","newPoints","point","i","isChild","tempRay","_raycaster","createRay","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","setDataEnabled","map","set","childPoints","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","childMapCircle","Map","raycaster","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","find","segmentIndex","findIndex","x1","y1","x2","y2","splice","closingSegment","matter","composite","Rectangle","min","max","closePath","last","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","index","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","intersections","GetLineToRectangle","distance","target","objects","mappedObjects","_boundingBox","setTo","Equals","isTangent","circleIntersections","GetLineToCircle","_stats","result","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","autoSlice","slicedIntersections","slice","castCone","cone","minAngle","maxAngle","angleOffset","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","abs","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","value","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","mask","setOnCollide","callback","self","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","func","bodyA","bodyB","onCollideWith","id","onCollideActiveCallback","setOnCollideWith","src","hasOwnProperty","overlap","targets","overlapCircle","isCollisionInfo","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","Triangle","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","version","mapPoint","mapSegment","mapBoundingBox","total","static","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","sortedPoints","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","debug","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","indexOf","enableMaps","disableMaps","dynamicMaps","mapppedObject","strokeRectShape"],"sourceRoot":""}